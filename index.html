<!doctype html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
<script src="twgl-full.min.js"></script>
<script src="dat.gui.min.js"></script>
<script src="seedrandom.min.js"></script>
<script src="Tone.js" integrity="sha512-nUjml8mN4CNYqBAy0ndDrd8pJV/eTtBNDsnvNtPqozx9/BccUeWSoKW14qWkQUnhuh8E3m+yra3qdzM68lqPEQ==" crossorigin="anonymous"></script>
<script src="ca.js" type="module"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-15552566-1"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());

gtag('config', 'UA-15552566-1');
</script>

<style>
html, body {
  margin: 0px;
  font-family: 'Google Sans', Arial, Helvetica, sans-serif;
  color: #FFF;
}
canvas {
  width: 100vw;
  height: 100vh;
}

#fsButton {
  position: fixed;
  z-index: 10;
  bottom: 20px; left:20px;
}

.centered { 
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

#info{
  width: 300px;
  background-color: rgba(0, 0, 0, 0.75);
  padding: 20px;
  z-index:5;
}

a:link {
  color: red;
}

a:visited {
  color: red;
}

.hint {
  font-size: min(10vw, 8vh);
  pointer-events: none;
  white-space: nowrap;
  opacity: 0;
}

.hint-anim {
  animation: fadeIn linear 2s;
}
@keyframes fadeIn {
  0% {opacity:0;}
  10% {opacity:1;}
  90% {opacity:1;}
  100% {opacity:0;}
}
</style>

<div id='hint' class='centered hint'>⇦ Swipe ⇨</div>

<div id='info' class='centered'>
  <p> <b style="font-size: large;">Hexells</b>
  <span style="font-size: smaller;">by <a href="https://twitter.com/zzznah">Alexander Mordvintsev</a><span>

  <p>
    is a Self-Organising System of cells, that was trained to build textures
    using neighbour communication only. This work exposes the relation between
    the life of an individual cell, and the cell collective as a whole.
  </p>
  <p>     The system is based on the 
    <a href="https://distill.pub/selforg/2021/textures/">Neural Cellular Automata</a>.
</p>

<p style="font-size: large;">
  Touch to interact; swipe left or right to change the pattern.
</p>

<div id="hideBtn" style="text-align: center;"><button>Hide</button></div>
</div>

<canvas id="glCanvas"></canvas>
<button id="fsButton">Fullscreen</button>


<script type="module">
  import { CA } from "./ca.js"
  import { Sonic } from "./sonic.js"

  const $ = q=>document.querySelector(q);

  const canvas = $('#glCanvas');

  const requestFullscreen = canvas.requestFullscreen
      || canvas.webkitRequestFullscreen || canvas.msRequestFullscreen;
  if (requestFullscreen === undefined) {
    $('#fsButton').style.display = 'none';
  }

  $('#fsButton').onclick = ()=>{
    const elem = canvas;
    const opt = { navigationUI: "hide" };
    if (elem.requestFullscreen) {
      elem.requestFullscreen(opt);
    } else if (elem.webkitRequestFullscreen) { /* Safari */
      elem.webkitRequestFullscreen(opt);
    } else if (elem.msRequestFullscreen) { /* IE11 */
      elem.msRequestFullscreen(opt);
    }
  };
  
  $('#hideBtn').onclick = ()=>{
    $('#info').style.display = 'none';
    $('#hint').classList.add('hint-anim');

  };

  const gl = canvas.getContext("webgl", { alpha: false });
  const gui = new dat.GUI();
  gui.hide();
  const param = {
    active: true,
    model: 149,
    brushRadius: 16,
    zoom: 1,
    stepPerFrame: 1,
    paintMode: false,
  };
  gui.add(param, 'active');
  gui.add(param, 'brushRadius', 1, 40);
  gui.add(param, 'zoom', 1.0, 64.0);
  gui.add(param, 'stepPerFrame', 0, 6);
  gui.add(param, 'paintMode', 0, 6);

  const query = new URLSearchParams(location.search);
  const seed = parseInt(query.get("seed"));
  if (seed) Math.seedrandom(seed);
  const page = parseInt(query.get("page"));

  $('#info').style.display = 'none';
  
  fetch('models.json').then(r => r.json()).then(models => {
    const onready = ()=>{
      if (page && seed) {
        param.active = false;
        const pageModels = [132, 149, 134, 168, 104];
        ca.paint(0, 0, -1, pageModels[page-1]);
        ca.disturb();

        for (let i=0; i<400; ++i) ca.step();
        $('#fsButton').style.display = "none";
        $('#info').style.display = 'none';
        canvas.width = 2412;
        canvas.height = 3074;
        const viewSize = [canvas.width, canvas.height];
        twgl.bindFramebufferInfo(gl);
        ca.draw(viewSize);
        const a = document.createElement('a');
        a.href = canvas.toDataURL("image/png");
        a.download = seed + '_' + page + '.png';
        a.click();
      }
    };
    const ca = new CA(gl, models, [160, 160], gui, onready);
    const sonic = new Sonic(gl, ca);
    //ca.alignment = 0;

    window.ca = ca;
    window.sonic = sonic;


    
    const name2idx = Object.fromEntries(models.model_names.map((s, i) => [s, i]));
    gui.add(param, 'model').options(name2idx).listen();

    function getMousePos(e) {
      return [e.offsetX, e.offsetY];
    }
    function getTouchPos(touch) {
      const rect = canvas.getBoundingClientRect();
      return [touch.clientX - rect.left, touch.clientY - rect.top];
    }

    const shuffledModels = [132, 141, 149, 134, 168, 40, 104, 37, 64, 126, 154, 133].concat(
      models.model_names.map((_, i)=>[Math.random(), i]).sort().map(p=>p[1]));
    //const shuffledModels = [132, 141, 149, 134, 168, 40, 104, 37, 64, 126, 154, 133];
    let initModelIdx = parseInt(window.location.hash.slice(1));
    if (isNaN(initModelIdx) || initModelIdx < 0 || initModelIdx >= shuffledModels.length) {
      initModelIdx = 132;
    }
    console.log(initModelIdx);
    ca.paint(0, 0, -1, initModelIdx);
    let curModel = shuffledModels.indexOf(initModelIdx);
    let gesture = null;
    function startGestue(pos) {
      gesture = {
        l: 0, r: 0, u: 0, d: 0,
        prevPos: pos,
        time: Date.now()
      };
    }
    function touch(pos) {
      const [x, y] = pos;
      const viewSize = [canvas.clientWidth, canvas.clientHeight];
      if ( param.paintMode ) {
        ca.paint(x, y, param.brushRadius, param.model, viewSize);
      } else {
        ca.clearCircle(x, y, param.brushRadius, viewSize);
        //ca.peek(x, y, viewSize);
      }
      if (gesture) {
        const [x0, y0] = gesture.prevPos;
        gesture.l += Math.max(x0-x, 0.0);
        gesture.r += Math.max(x-x0, 0.0);
        gesture.u += Math.max(y0-y, 0.0);
        gesture.d += Math.max(y-y0, 0.0);
        gesture.prevPos = pos;
      }
    }    

    function switchModel(swipe) {
      const n = shuffledModels.length;
      curModel = (curModel+n+swipe) % n;
      const i = shuffledModels[curModel];
      ca.paint(0, 0, -1, i);
      ca.disturb();
      console.log(i);
      window.location.hash = i;
    }

    document.addEventListener('keypress', e=>{
      if (e.key == 'a') switchModel(1);
      if (e.key == 'z') switchModel(-1);
    });

    function endGestue(pos) {
      if (!gesture)
       return;
      if (Date.now()-gesture.time < 1000) {
        const {l, r, u, d} = gesture;
        let swipe = 0;
        if (l>100 && Math.max(r, u, d)<l*0.25) swipe = -1;
        if (r>100 && Math.max(l, u, d)<r*0.25) swipe = 1;
        if (swipe != 0)  {
          switchModel(swipe);
        }
      }
      gesture = null;
    }

    let lastMousePos = null;

    canvas.onmousedown = e => {
      e.preventDefault();
      if (e.buttons == 1) {
        const pos = getMousePos(e);
        lastMousePos = pos;
        //touch(pos);
        startGestue(pos);
        const [x, y] = pos;
        const viewSize = [canvas.clientWidth, canvas.clientHeight];
        const state = ca.peek(x, y, viewSize);
        sonic.start(state);
      }
    }
    canvas.onmousemove = e => {
      e.preventDefault();
      if (e.buttons == 1) {
        const pos = getMousePos(e);
        const [x, y] = pos, [px, py] = lastMousePos;
        if (Math.abs(x-px)+Math.abs(y-py) > 10)
          touch(pos);
        lastMousePos = pos;
      }
    }
    canvas.onmouseup = e => {
      e.preventDefault();
      endGestue(getMousePos(e));
      lastMousePos = null;
      sonic.stop();
    }

    canvas.addEventListener("touchstart", e => {
      e.preventDefault();
      const pos = getTouchPos(e.changedTouches[0]);
      lastMousePos = pos;
      touch(pos);
      if (e.touches.length == 1) {
        startGestue(pos);
      } else {
        gesture = null; //cancel guesture
      }
      sonic.start();
    });
    canvas.addEventListener("touchmove", e => {
      e.preventDefault();
      for (const t of e.touches) {
        const pos = getTouchPos(t);
        //touch(pos);
        lastMousePos = pos;
      }
    });
    canvas.addEventListener("touchend", e => {
      e.preventDefault();
      endGestue(getTouchPos(e.changedTouches[0]));
      sonic.stop();
    });
    param.benchmark = ()=>{
      $('#log').insertAdjacentHTML('afterbegin', ca.benchmark());
    }
    gui.add(param, 'benchmark');

    function render() {
      if (param.active) {
        ca.step();
      }
      
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.round(canvas.clientWidth * dpr);
      canvas.height = Math.round(canvas.clientHeight * dpr);      
      const viewSize = [canvas.clientWidth, canvas.clientHeight];

      if (lastMousePos) {
        const [x, y] = lastMousePos;
        const state = ca.peek(x, y, viewSize);
        sonic.update(state);
      }

      twgl.bindFramebufferInfo(gl);
      ca.draw(viewSize, 'color');
      sonic.draw(viewSize);
      // if (lastMousePos) {
      //   const d=200;
      //   gl.viewport(0, 0, 500*dpr, 32*dpr);
      //   ca.draw(viewSize, 'sonic');
      // }
      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
  })
</script>
